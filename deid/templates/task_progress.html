{% extends 'base.html' %}

{% block title %}{{ module_name }} ({{ project_name }}){% endblock %}

{% block content %}
<div class="px-4">
    <h1 class="text-xl flex-1">{{ module_name }} ({{ project_name }})</h1>
    <div id="folderLinks" class="mt-4 bg-white p-3 rounded-t text-xs hidden flex justify-between">
        <button id="openOutputFolder" class="px-2 py-1 bg-white shadow text-xs hover:bg-gray-100">Open output folder</button>
        <div>
            <button id="openAppdataFolder" class="px-2 py-1 bg-white shadow text-xs hover:bg-gray-100 mr-2">Open appdata folder</button>
            <button id="openLogsFolder" class="px-2 py-1 bg-white shadow text-xs hover:bg-gray-100 mr-2">Open logs folder</button>
            <button id="cancelTask" class="px-2 py-1 bg-white shadow text-xs hover:bg-gray-100 text-orange-600 hover:text-orange-900 hidden">Cancel task</button>
        </div>
    </div>
    <div id="errorPopup" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full">
        <div class="relative top-40 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
            <div class="mt-3 text-center">
                <h3 class="text-lg leading-6 font-medium text-gray-900">Error</h3>
                <div class="mt-2 px-7 py-3">
                    <p id="errorMessage" class="text-sm text-gray-500"></p>
                </div>
                <div class="items-center px-4 py-3 flex justify-center gap-3">
                    <button id="openLogsError" class="px-4 py-2 bg-blue-500 text-white text-base font-medium rounded-md shadow-sm hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-300 opacity-50 cursor-not-allowed" disabled>
                        Open Logs
                    </button>
                    <button id="closeError" class="px-4 py-2 bg-red-500 text-white text-base font-medium rounded-md shadow-sm hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-300">
                        Close
                    </button>
                </div>
            </div>
        </div>
    </div>
    <div id="cancelledPopup" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full">
        <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
            <div class="mt-3 text-center">
                <h3 id="cancelledTitle" class="text-lg leading-6 font-medium text-gray-900">Task Cancelled</h3>
                <div class="mt-2 px-7 py-3">
                    <p id="cancelledMessage" class="text-sm text-gray-500"></p>
                </div>
                <div class="items-center px-4 py-3">
                    <button id="closeCancelled" class="px-4 py-2 bg-green-500 text-white text-base font-medium rounded-md shadow-sm hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-300">
                        Close
                    </button>
                </div>
            </div>
        </div>
    </div>
    <pre class="bg-black text-white p-4 font-mono text-xs h-[calc(100vh-13rem-45px)] overflow-y-auto whitespace-pre-wrap" id="logContent">
    </pre>
</div>

<script>
    const urlParams = new URLSearchParams(window.location.search);
    const projectId = urlParams.get('project_id');
    let logPath = null;
    let logsFolder = null;
    let outputFolder = null;
    let appdataFolder = null;
    let previousContent = '';
    let sameContentCount = 0;
    let pollInterval;
    let statusInterval;
    let hasError = false;
    let taskStatus = null;
    
    // List of error messages from validate_config
    const errorMessages = [
        "Config file unable to load or invalid.",
        "Module not specified in config file.",
        "Module invalid or not implemented.",
        "Input directory not found.",
        "Output directory must be empty.",
        "Pacs details missing in config file.",
        "Either the accession column name or mrn + date column names are required.",
        "Can only query using one of accession or mrn + date. Not both.",
        "Date window must be an integer.",
        "No DICOM files found in input directory.",
        "Input directory must contain input.xlsx file.",
        "Invalid CTP filters.",
        "Invalid CTP anonymizer.",
        "Invalid excel file."
    ];

    async function checkTaskStatus() {
        if (hasError) return;

        try {
            const response = await fetch(`/api/task_status/${projectId}`);
            const data = await response.json();
            
            taskStatus = data.status;
            
            if (data.log_path && data.log_path !== '' && data.log_path !== logPath) {
                logPath = data.log_path;
                console.log('Log path updated to:', logPath);
            }
            
            if (data.logs_folder) {
                logsFolder = data.logs_folder;
            }
            if (data.output_folder) {
                outputFolder = data.output_folder;
            }
            if (data.appdata_folder) {
                appdataFolder = data.appdata_folder;
            }
            
            updateFolderLinks();
            updateCancelButton();
            
            if (data.status === 'FAILED') {
                hasError = true;
                document.getElementById('errorMessage').textContent = "Task has failed. Please check the logs for details.";
                document.getElementById('errorPopup').classList.remove('hidden');
                clearInterval(pollInterval);
                clearInterval(statusInterval);
                return;
            }
            
            if (data.status === 'CANCELLED') {
                hasError = true;
                document.getElementById('cancelledMessage').textContent = "Task has been cancelled.";
                document.getElementById('cancelledPopup').classList.remove('hidden');
                clearInterval(pollInterval);
                clearInterval(statusInterval);
                setTimeout(() => {
                    window.location.href = '/task_list';
                }, 3000);
                return;
            }
        } catch (error) {
            console.error('Error checking task status:', error);
        }
    }
    
    function updateFolderLinks() {
        const folderLinksDiv = document.getElementById('folderLinks');
        const openLogsBtn = document.getElementById('openLogsFolder');
        const openLogsErrorBtn = document.getElementById('openLogsError');
        const openOutputBtn = document.getElementById('openOutputFolder');
        const openAppdataBtn = document.getElementById('openAppdataFolder');

        if (logsFolder || outputFolder || appdataFolder) {
            folderLinksDiv.classList.remove('hidden');
        }

        if (logsFolder) {
            openLogsBtn.onclick = async () => {
                if (window.electronAPI && window.electronAPI.openFolder) {
                    await window.electronAPI.openFolder(logsFolder);
                }
            };
            openLogsBtn.disabled = false;
            openLogsBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            openLogsErrorBtn.disabled = false;
            openLogsErrorBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        } else {
            openLogsBtn.disabled = true;
            openLogsBtn.classList.add('opacity-50', 'cursor-not-allowed');
            openLogsErrorBtn.disabled = true;
            openLogsErrorBtn.classList.add('opacity-50', 'cursor-not-allowed');
        }
        
        if (outputFolder) {
            openOutputBtn.onclick = async () => {
                if (window.electronAPI && window.electronAPI.openFolder) {
                    await window.electronAPI.openFolder(outputFolder);
                }
            };
            openOutputBtn.disabled = false;
            openOutputBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        } else {
            openOutputBtn.disabled = true;
            openOutputBtn.classList.add('opacity-50', 'cursor-not-allowed');
        }
        
        if (appdataFolder) {
            openAppdataBtn.onclick = async () => {
                if (window.electronAPI && window.electronAPI.openFolder) {
                    await window.electronAPI.openFolder(appdataFolder);
                }
            };
            openAppdataBtn.disabled = false;
            openAppdataBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        } else {
            openAppdataBtn.disabled = true;
            openAppdataBtn.classList.add('opacity-50', 'cursor-not-allowed');
        }
    }
    
    function updateCancelButton() {
        const cancelBtn = document.getElementById('cancelTask');
        
        if (taskStatus === 'PENDING' || taskStatus === 'RUNNING') {
            cancelBtn.classList.remove('hidden');
        } else {
            cancelBtn.classList.add('hidden');
        }
    }
    
    function getCsrfToken() {
        return document.querySelector('meta[name="csrf_token"]').getAttribute('content');
    }
    
    async function cancelTask() {
        if (!confirm('Are you sure you want to cancel this task?')) {
            return;
        }
        
        try {
            const response = await fetch(`/cancel_task/${projectId}/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCsrfToken(),
                },
            });
            
            if (response.ok) {
                hasError = true;
                document.getElementById('cancelledTitle').textContent = "Cancelling Task";
                document.getElementById('cancelledMessage').textContent = "Task is being cancelled...";
                document.getElementById('cancelledPopup').classList.remove('hidden');
                clearInterval(pollInterval);
                clearInterval(statusInterval);
                setTimeout(() => {
                    window.location.href = '/task_list';
                }, 2000);
            } else {
                const result = await response.json();
                alert('Failed to cancel task: ' + (result.message || 'Unknown error'));
            }
        } catch (error) {
            console.error('Error:', error);
            alert('Failed to cancel task: ' + error.message);
        }
    }
    
    async function fetchLogContent() {
        if (hasError) return;
        
        if (!logPath || logPath === '') {
            document.getElementById('logContent').textContent = 'Loading. Please wait...';
            return;
        }
        
        try {
            const response = await fetch(`/get_log_content?log_path=${encodeURIComponent(logPath)}`);
            const data = await response.text();
            const logContent = document.getElementById('logContent');
            
            if (data === previousContent) {
                sameContentCount++;
                if (sameContentCount >= 200) {
                    clearInterval(pollInterval);
                    clearInterval(statusInterval);
                }
                return;
            }
            
            sameContentCount = 0;
            previousContent = data;
            logContent.textContent = data;
            logContent.scrollTop = logContent.scrollHeight;
        } catch (error) {
            console.error('Error fetching log:', error);
        }
    }

    // Handle opening logs from the error popup
    document.getElementById('openLogsError').addEventListener('click', async function() {
        if (logsFolder && window.electronAPI && window.electronAPI.openFolder) {
            await window.electronAPI.openFolder(logsFolder);
        }
    });

    // Handle closing the error popup
    document.getElementById('closeError').addEventListener('click', function() {
        document.getElementById('errorPopup').classList.add('hidden');
        window.history.back(); // Return to previous page
    });
    
    // Handle cancel button click
    document.getElementById('cancelTask').addEventListener('click', cancelTask);

    // Initial fetch
    fetchLogContent();
    checkTaskStatus();

    // Poll every second for log content
    pollInterval = setInterval(fetchLogContent, 1000);
    
    // Check task status every 5 seconds
    statusInterval = setInterval(checkTaskStatus, 5000);
</script>
{% endblock %}
