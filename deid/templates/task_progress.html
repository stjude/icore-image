{% extends 'base.html' %}

{% block title %}{{ module_name }} ({{ project_name }}){% endblock %}

{% block content %}
<div class="px-4">
    <h1 class="text-xl flex-1">{{ module_name }} ({{ project_name }})</h1>
    <div id="folderLinks" class="mt-4 bg-white p-3 rounded-t text-xs hidden flex justify-between">
        <button id="openOutputFolder" class="px-2 py-1 bg-white shadow text-xs hover:bg-gray-100">Open output folder</button>
        <div>
            <button id="openAppdataFolder" class="px-2 py-1 bg-white shadow text-xs hover:bg-gray-100 mr-2">Open appdata folder</button>
            <button id="openLogsFolder" class="px-2 py-1 bg-white shadow text-xs hover:bg-gray-100">Open logs folder</button>
        </div>
    </div>
    <div id="errorPopup" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full">
        <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
            <div class="mt-3 text-center">
                <h3 class="text-lg leading-6 font-medium text-gray-900">Error</h3>
                <div class="mt-2 px-7 py-3">
                    <p id="errorMessage" class="text-sm text-gray-500"></p>
                </div>
                <div class="items-center px-4 py-3">
                    <button id="closeError" class="px-4 py-2 bg-red-500 text-white text-base font-medium rounded-md shadow-sm hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-300">
                        Close
                    </button>
                </div>
            </div>
        </div>
    </div>
    <pre class="bg-black text-white p-4 font-mono text-xs h-[calc(100vh-13rem-45px)] overflow-y-auto whitespace-pre-wrap" id="logContent">
    </pre>
</div>

<script>
    const urlParams = new URLSearchParams(window.location.search);
    const projectId = urlParams.get('project_id');
    let logPath = null;
    let logsFolder = null;
    let outputFolder = null;
    let appdataFolder = null;
    let previousContent = '';
    let sameContentCount = 0;
    let pollInterval;
    let hasError = false;
    
    // List of error messages from validate_config
    const errorMessages = [
        "Config file unable to load or invalid.",
        "Module not specified in config file.",
        "Module invalid or not implemented.",
        "Input directory not found.",
        "Output directory must be empty.",
        "Pacs details missing in config file.",
        "Either the accession column name or mrn + date column names are required.",
        "Can only query using one of accession or mrn + date. Not both.",
        "Date window must be an integer.",
        "No DICOM files found in input directory.",
        "Input directory must contain input.xlsx file.",
        "Invalid CTP filters.",
        "Invalid CTP anonymizer.",
        "Invalid excel file."
    ];

    async function checkTaskStatus() {
        if (hasError) return;

        try {
            const response = await fetch(`/api/task_status/${projectId}`);
            const data = await response.json();
            
            if (data.log_path && data.log_path !== '' && data.log_path !== logPath) {
                logPath = data.log_path;
                console.log('Log path updated to:', logPath);
            }
            
            if (data.logs_folder) {
                logsFolder = data.logs_folder;
            }
            if (data.output_folder) {
                outputFolder = data.output_folder;
            }
            if (data.appdata_folder) {
                appdataFolder = data.appdata_folder;
            }
            
            updateFolderLinks();
            
            if (data.status === 'FAILED') {
                hasError = true;
                document.getElementById('errorMessage').textContent = "Task has failed. Please check the logs for details.";
                document.getElementById('errorPopup').classList.remove('hidden');
                clearInterval(pollInterval);
                clearInterval(statusInterval);
                setTimeout(() => {
                    window.location.href = '/task_list';
                }, 3000);
                return;
            }
        } catch (error) {
            console.error('Error checking task status:', error);
        }
    }
    
    function updateFolderLinks() {
        const folderLinksDiv = document.getElementById('folderLinks');
        const openLogsBtn = document.getElementById('openLogsFolder');
        const openOutputBtn = document.getElementById('openOutputFolder');
        const openAppdataBtn = document.getElementById('openAppdataFolder');
        
        if (logsFolder || outputFolder || appdataFolder) {
            folderLinksDiv.classList.remove('hidden');
        }
        
        if (logsFolder) {
            openLogsBtn.onclick = async () => {
                if (window.electronAPI && window.electronAPI.openFolder) {
                    await window.electronAPI.openFolder(logsFolder);
                }
            };
            openLogsBtn.disabled = false;
            openLogsBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        } else {
            openLogsBtn.disabled = true;
            openLogsBtn.classList.add('opacity-50', 'cursor-not-allowed');
        }
        
        if (outputFolder) {
            openOutputBtn.onclick = async () => {
                if (window.electronAPI && window.electronAPI.openFolder) {
                    await window.electronAPI.openFolder(outputFolder);
                }
            };
            openOutputBtn.disabled = false;
            openOutputBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        } else {
            openOutputBtn.disabled = true;
            openOutputBtn.classList.add('opacity-50', 'cursor-not-allowed');
        }
        
        if (appdataFolder) {
            openAppdataBtn.onclick = async () => {
                if (window.electronAPI && window.electronAPI.openFolder) {
                    await window.electronAPI.openFolder(appdataFolder);
                }
            };
            openAppdataBtn.disabled = false;
            openAppdataBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        } else {
            openAppdataBtn.disabled = true;
            openAppdataBtn.classList.add('opacity-50', 'cursor-not-allowed');
        }
    }
    
    async function fetchLogContent() {
        if (hasError) return;
        
        if (!logPath || logPath === '') {
            document.getElementById('logContent').textContent = 'Loading. Please wait...';
            return;
        }
        
        try {
            const response = await fetch(`/get_log_content?log_path=${encodeURIComponent(logPath)}`);
            const data = await response.text();
            const logContent = document.getElementById('logContent');
            
            if (data === previousContent) {
                sameContentCount++;
                if (sameContentCount >= 200) {
                    clearInterval(pollInterval);
                    clearInterval(statusInterval);
                }
                return;
            }
            
            sameContentCount = 0;
            previousContent = data;
            logContent.textContent = data;
            logContent.scrollTop = logContent.scrollHeight;
        } catch (error) {
            console.error('Error fetching log:', error);
        }
    }

    // Handle closing the error popup
    document.getElementById('closeError').addEventListener('click', function() {
        document.getElementById('errorPopup').classList.add('hidden');
        window.history.back(); // Return to previous page
    });

    // Initial fetch
    fetchLogContent();
    checkTaskStatus();

    // Poll every second for log content
    pollInterval = setInterval(fetchLogContent, 1000);
    
    // Check task status every 5 seconds
    const statusInterval = setInterval(checkTaskStatus, 5000);
</script>
{% endblock %}
